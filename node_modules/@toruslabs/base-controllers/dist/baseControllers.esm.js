import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';
import _inherits from '@babel/runtime/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { SafeEventEmitter, JRPCEngine, createAsyncMiddleware, mergeMiddleware, createScaffoldMiddleware } from '@toruslabs/openlogin-jrpc';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _get from '@babel/runtime/helpers/get';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { serializeError, ethErrors } from 'eth-rpc-errors';
import getCreateRandomId from 'json-rpc-random-id';
import _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';
import { BigNumber } from 'bignumber.js';
import { fromSigned, bufferToInt, toUnsigned, stripHexPrefix, addHexPrefix, hashPersonalMessage, ecsign, intToBuffer } from 'ethereumjs-util';
import log from 'loglevel';
import { BroadcastChannel } from '@toruslabs/broadcast-channel';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import { get, post, patch, remove } from '@toruslabs/http-helpers';
import bowser from 'bowser';
import { cloneDeep, pickBy, omitBy } from 'lodash';

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Controller class that provides configuration, state management, and subscriptions
 */
var BaseController = /*#__PURE__*/function (_SafeEventEmitter) {
  _inherits(BaseController, _SafeEventEmitter);
  var _super = _createSuper$b(BaseController);
  /**
   * Default options used to configure this controller
   */

  /**
   * Default state set on this controller
   */

  /**
   * Determines if listeners are notified of state changes
   */

  /**
   * Name of this controller used during composition
   */

  /**
   * Creates a BaseController instance. Both initial state and initial
   * configuration options are merged with defaults upon initialization.
   *
   * @param config - Initial options used to configure this controller
   * @param state - Initial state to set on this controller
   */
  function BaseController(_ref) {
    var _this;
    var _ref$config = _ref.config,
      config = _ref$config === void 0 ? {} : _ref$config,
      _ref$state = _ref.state,
      state = _ref$state === void 0 ? {} : _ref$state;
    _classCallCheck(this, BaseController);
    _this = _super.call(this);
    // Use assign since generics can't be spread: https://git.io/vpRhY
    _defineProperty(_assertThisInitialized(_this), "defaultConfig", {});
    _defineProperty(_assertThisInitialized(_this), "defaultState", {});
    _defineProperty(_assertThisInitialized(_this), "disabled", false);
    _defineProperty(_assertThisInitialized(_this), "name", "BaseController");
    _defineProperty(_assertThisInitialized(_this), "initialConfig", void 0);
    _defineProperty(_assertThisInitialized(_this), "initialState", void 0);
    _defineProperty(_assertThisInitialized(_this), "internalConfig", _this.defaultConfig);
    _defineProperty(_assertThisInitialized(_this), "internalState", _this.defaultState);
    _this.initialState = state;
    _this.initialConfig = config;
    return _this;
  }
  /**
   * Retrieves current controller configuration options
   *
   * @returns - Current configuration
   */
  _createClass(BaseController, [{
    key: "config",
    get: function get() {
      return this.internalConfig;
    }
    /**
     * Retrieves current controller state
     *
     * @returns - Current state
     */
  }, {
    key: "state",
    get: function get() {
      return this.internalState;
    }
    /**
     * Updates controller configuration
     *
     * @param config - New configuration options
     * @param overwrite - Overwrite config instead of merging
     * @param fullUpdate - Boolean that defines if the update is partial or not
     */
  }, {
    key: "configure",
    value: function configure(config) {
      var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var fullUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      if (fullUpdate) {
        this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);
        for (var key in this.internalConfig) {
          if (typeof this.internalConfig[key] !== "undefined") {
            this[key] = this.internalConfig[key];
          }
        }
      } else {
        for (var _key in config) {
          /* istanbul ignore else */
          if (typeof this.internalConfig[_key] !== "undefined") {
            this.internalConfig[_key] = config[_key];
            this[_key] = config[_key];
          }
        }
      }
    }
    /**
     * Updates controller state
     *
     * @param state - New state
     * @param overwrite - Overwrite state instead of merging
     */
  }, {
    key: "update",
    value: function update(state) {
      var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.internalState = overwrite ? _objectSpread$3({}, state) : _objectSpread$3(_objectSpread$3({}, this.internalState), state);
      this.emit("store", this.internalState);
    }
    /**
     * Enables the controller. This sets each config option as a member
     * variable on this instance and triggers any defined setters. This
     * also sets initial state and triggers any listeners.
     *
     * @returns - This controller instance
     */
  }, {
    key: "initialize",
    value: function initialize() {
      this.internalState = this.defaultState;
      this.internalConfig = this.defaultConfig;
      this.configure(this.initialConfig);
      this.update(this.initialState);
      return this;
    }
  }]);
  return BaseController;
}(SafeEventEmitter);

function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var sec = 1000;
var calculateSum = function calculateSum(accumulator, currentValue) {
  return accumulator + currentValue;
};
var blockTrackerEvents = ["sync", "latest"];
var BaseBlockTracker = /*#__PURE__*/function (_BaseController) {
  _inherits(BaseBlockTracker, _BaseController);
  var _super = _createSuper$a(BaseBlockTracker);
  function BaseBlockTracker(_ref) {
    var _this;
    var _ref$config = _ref.config,
      config = _ref$config === void 0 ? {} : _ref$config,
      _ref$state = _ref.state,
      state = _ref$state === void 0 ? {} : _ref$state;
    _classCallCheck(this, BaseBlockTracker);
    _this = _super.call(this, {
      config: config,
      state: state
    });
    // config
    _defineProperty(_assertThisInitialized(_this), "name", "BaseBlockTracker");
    _defineProperty(_assertThisInitialized(_this), "_blockResetTimeout", void 0);
    _this.defaultState = {
      _currentBlock: {
        idempotencyKey: ""
      },
      _isRunning: false
    };
    _this.defaultConfig = {
      blockResetDuration: 20 * sec
    };
    _this.initialize();
    // bind functions for internal use
    _this._onNewListener = _this._onNewListener.bind(_assertThisInitialized(_this));
    _this._onRemoveListener = _this._onRemoveListener.bind(_assertThisInitialized(_this));
    _this._resetCurrentBlock = _this._resetCurrentBlock.bind(_assertThisInitialized(_this));
    // listen for handler changes
    _this._setupInternalEvents();
    return _this;
  }
  _createClass(BaseBlockTracker, [{
    key: "isRunning",
    value: function isRunning() {
      return this.state._isRunning;
    }
  }, {
    key: "getCurrentBlock",
    value: function getCurrentBlock() {
      return this.state._currentBlock;
    }
  }, {
    key: "getLatestBlock",
    value: function () {
      var _getLatestBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _this2 = this;
        var latestBlock;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.state._currentBlock) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return", this.state._currentBlock);
              case 2:
                _context.next = 4;
                return new Promise(function (resolve) {
                  _this2.once("latest", function (newState) {
                    if (newState._currentBlock) {
                      resolve(newState._currentBlock);
                    }
                  });
                });
              case 4:
                latestBlock = _context.sent;
                return _context.abrupt("return", latestBlock);
              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function getLatestBlock() {
        return _getLatestBlock.apply(this, arguments);
      }
      return getLatestBlock;
    }() // dont allow module consumer to remove our internal event listeners
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners(eventName) {
      if (eventName) {
        _get(_getPrototypeOf(BaseBlockTracker.prototype), "removeAllListeners", this).call(this, eventName);
      } else {
        _get(_getPrototypeOf(BaseBlockTracker.prototype), "removeAllListeners", this).call(this);
      }
      // re-add internal events
      this._setupInternalEvents();
      // trigger stop check just in case
      this._onRemoveListener();
      return this;
    }
    /**
     * To be implemented in subclass.
     */
  }, {
    key: "_start",
    value: function _start() {
      // default behavior is noop
    }
    /**
     * To be implemented in subclass.
     */
  }, {
    key: "_end",
    value: function _end() {
      // default behavior is noop
    }
  }, {
    key: "_newPotentialLatest",
    value: function _newPotentialLatest(newBlock) {
      var currentBlock = this.state._currentBlock;
      // only update if blok number is higher
      if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {
        return;
      }
      this._setCurrentBlock(newBlock);
    }
  }, {
    key: "_setupInternalEvents",
    value: function _setupInternalEvents() {
      // first remove listeners for idempotency
      this.removeListener("newListener", this._onNewListener);
      this.removeListener("removeListener", this._onRemoveListener);
      // then add them
      this.on("removeListener", this._onRemoveListener);
      this.on("newListener", this._onNewListener);
    }
  }, {
    key: "_onNewListener",
    value: function _onNewListener() {
      this._maybeStart();
    }
  }, {
    key: "_onRemoveListener",
    value: function _onRemoveListener() {
      // `removeListener` is called *after* the listener is removed
      if (this._getBlockTrackerEventCount() > 0) {
        return;
      }
      this._maybeEnd();
    }
  }, {
    key: "_maybeStart",
    value: function _maybeStart() {
      if (this.state._isRunning) {
        return;
      }
      this.state._isRunning = true;
      // cancel setting latest block to stale
      this._cancelBlockResetTimeout();
      this._start();
    }
  }, {
    key: "_maybeEnd",
    value: function _maybeEnd() {
      if (!this.state._isRunning) {
        return;
      }
      this.state._isRunning = false;
      this._setupBlockResetTimeout();
      this._end();
    }
  }, {
    key: "_getBlockTrackerEventCount",
    value: function _getBlockTrackerEventCount() {
      var _this3 = this;
      return blockTrackerEvents.map(function (eventName) {
        return _this3.listenerCount(eventName);
      }).reduce(calculateSum);
    }
  }, {
    key: "_setCurrentBlock",
    value: function _setCurrentBlock(newBlock) {
      var oldBlock = this.state._currentBlock;
      this.update({
        _currentBlock: newBlock
      });
      this.emit("latest", newBlock);
      this.emit("sync", {
        oldBlock: oldBlock,
        newBlock: newBlock
      });
    }
  }, {
    key: "_setupBlockResetTimeout",
    value: function _setupBlockResetTimeout() {
      // clear any existing timeout
      this._cancelBlockResetTimeout();
      // clear latest block when stale
      this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration);
      // nodejs - dont hold process open
      if (this._blockResetTimeout.unref) {
        this._blockResetTimeout.unref();
      }
    }
  }, {
    key: "_cancelBlockResetTimeout",
    value: function _cancelBlockResetTimeout() {
      if (this._blockResetTimeout) {
        clearTimeout(this._blockResetTimeout);
      }
    }
  }, {
    key: "_resetCurrentBlock",
    value: function _resetCurrentBlock() {
      this.update({
        _currentBlock: {
          idempotencyKey: ""
        }
      });
    }
  }]);
  return BaseBlockTracker;
}(BaseController);

var filterNoop = function filterNoop() {
  return true;
};
var internalEvents = ["newListener", "removeListener"];
var externalEventFilter = function externalEventFilter(name) {
  return !internalEvents.includes(name);
};
function getRawListeners(eventEmitter, name) {
  // prefer native
  return eventEmitter.rawListeners(name);
}
function createEventEmitterProxy(initialTarget, opts) {
  // parse options
  var finalOpts = opts || {};
  var eventFilter = finalOpts.eventFilter || filterNoop;
  if (typeof eventFilter === "string" && eventFilter === "skipInternal") eventFilter = externalEventFilter;
  if (typeof eventFilter !== "function") throw new Error("createEventEmitterProxy - Invalid eventFilter");
  var target = initialTarget;
  var setTarget = function setTarget(newTarget) {
    var oldTarget = target;
    target = newTarget;
    oldTarget.eventNames().filter(eventFilter).forEach(function (name) {
      getRawListeners(oldTarget, name).forEach(function (handler) {
        return newTarget.on(name, handler);
      });
    });
    // remove old listeners
    oldTarget.removeAllListeners();
  };
  var proxy = new Proxy({}, {
    get: function get(_, name) {
      // override `setTarget` access
      if (name === "setTarget") return setTarget;
      return target[name];
    },
    set: function set(_, name, value) {
      // allow `setTarget` overrides
      if (name === "setTarget") {
        setTarget = value;
        return true;
      }
      target[name] = value;
      return true;
    }
  });
  return proxy;
}

function createSwappableProxy(initialTarget) {
  var target = initialTarget;
  var setTarget = function setTarget(newTarget) {
    target = newTarget;
  };
  var proxy = new Proxy({}, {
    get: function get(_, name) {
      // override `setTarget` access
      if (name === "setTarget") return setTarget;
      return target[name];
    },
    set: function set(_, name, value) {
      // allow `setTarget` overrides
      if (name === "setTarget") {
        setTarget = value;
        return true;
      }
      target[name] = value;
      return true;
    }
  });
  return proxy;
}

function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// every ten minutes
var POLLING_INTERVAL = 600000;
var BaseCurrencyController = /*#__PURE__*/function (_BaseController) {
  _inherits(BaseCurrencyController, _BaseController);
  var _super = _createSuper$9(BaseCurrencyController);
  function BaseCurrencyController(_ref) {
    var _this;
    var _ref$config = _ref.config,
      config = _ref$config === void 0 ? {} : _ref$config,
      state = _ref.state;
    _classCallCheck(this, BaseCurrencyController);
    _this = _super.call(this, {
      config: config,
      state: state
    });
    _this.defaultState = {
      currentCurrency: "usd",
      conversionRate: 0,
      conversionDate: "N/A",
      nativeCurrency: "ETH"
    };
    _this.defaultConfig = {
      pollInterval: POLLING_INTERVAL
    };
    _this.initialize();
    return _this;
  }
  //
  // PUBLIC METHODS
  //
  _createClass(BaseCurrencyController, [{
    key: "getNativeCurrency",
    value: function getNativeCurrency() {
      return this.state.nativeCurrency;
    }
  }, {
    key: "setNativeCurrency",
    value: function setNativeCurrency(nativeCurrency) {
      this.update({
        nativeCurrency: nativeCurrency,
        ticker: nativeCurrency
      });
    }
  }, {
    key: "getCurrentCurrency",
    value: function getCurrentCurrency() {
      return this.state.currentCurrency;
    }
  }, {
    key: "setCurrentCurrency",
    value: function setCurrentCurrency(currentCurrency) {
      this.update({
        currentCurrency: currentCurrency
      });
    }
    /**
     * A getter for the conversionRate property
     *
     * @returns The conversion rate from ETH to the selected currency.
     *
     */
  }, {
    key: "getConversionRate",
    value: function getConversionRate() {
      return this.state.conversionRate;
    }
  }, {
    key: "setConversionRate",
    value: function setConversionRate(conversionRate) {
      this.update({
        conversionRate: conversionRate
      });
    }
    /**
     * A getter for the conversionDate property
     *
     * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of
     * January 1, 1970
     *
     */
  }, {
    key: "getConversionDate",
    value: function getConversionDate() {
      return this.state.conversionDate;
    }
  }, {
    key: "setConversionDate",
    value: function setConversionDate(conversionDate) {
      this.update({
        conversionDate: conversionDate
      });
    }
  }]);
  return BaseCurrencyController;
}(BaseController);

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var createRandomId = getCreateRandomId();
function providerFromEngine(engine) {
  var provider = new SafeEventEmitter();
  // handle both rpc send methods
  provider.sendAsync = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(req) {
      var res, _res$error, _res$error2, err;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return engine.handle(req);
            case 2:
              res = _context.sent;
              if (!res.error) {
                _context.next = 6;
                break;
              }
              err = serializeError(res.error, {
                fallbackError: {
                  message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || res.error.toString(),
                  code: ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.code) || -32603
                }
              });
              throw ethErrors.rpc.internal(err);
            case 6:
              return _context.abrupt("return", res.result);
            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  provider.send = function (req, callback) {
    if (typeof callback !== "function") {
      throw new Error('Must provide callback to "send" method.');
    }
    engine.handle(req, callback);
  };
  // forward notifications
  if (engine.on) {
    engine.on("notification", function (message) {
      provider.emit("data", null, message);
    });
  }
  provider.request = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(args) {
      var req, res;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              req = _objectSpread$2(_objectSpread$2({}, args), {}, {
                id: createRandomId(),
                jsonrpc: "2.0"
              });
              _context2.next = 3;
              return provider.sendAsync(req);
            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", res);
            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  return provider;
}
function providerFromMiddleware(middleware) {
  var engine = new JRPCEngine();
  engine.push(middleware);
  var provider = providerFromEngine(engine);
  return provider;
}
function providerAsMiddleware(provider) {
  return /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(req, res, _next, end) {
      var providerRes;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return provider.sendAsync(req);
            case 3:
              providerRes = _context3.sent;
              res.result = providerRes;
              return _context3.abrupt("return", end());
            case 8:
              _context3.prev = 8;
              _context3.t0 = _context3["catch"](0);
              return _context3.abrupt("return", end(_context3.t0.message));
            case 11:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[0, 8]]);
    }));
    return function (_x3, _x4, _x5, _x6) {
      return _ref3.apply(this, arguments);
    };
  }();
}

var FEATURES_PROVIDER_CHANGE_WINDOW = {
  height: 660,
  width: 375
};
var FEATURES_DEFAULT_WALLET_WINDOW = {
  height: 740,
  width: 1315
};
var FEATURES_DEFAULT_POPUP_WINDOW = {
  height: 700,
  width: 1200
};
var FEATURES_CONFIRM_WINDOW = {
  height: 700,
  width: 450
};
var POPUP_LOADED = "popup_loaded";
var POPUP_RESULT = "popup_result";
var SETUP_COMPLETE = "setup_complete";
var ACTIVITY_ACTION_ALL = "walletActivity.allTransactions";
var ACTIVITY_ACTION_SEND = "walletActivity.send";
var ACTIVITY_ACTION_BURN = "walletActivity.burn";
var ACTIVITY_ACTION_RECEIVE = "walletActivity.receive";
var ACTIVITY_ACTION_TOPUP = "walletActivity.topup";
var ACTIVITY_PERIOD_ALL = "walletActivity.all";
var ACTIVITY_PERIOD_WEEK_ONE = "walletActivity.lastOneWeek";
var ACTIVITY_PERIOD_MONTH_ONE = "walletActivity.lastOneMonth";
var ACTIVITY_PERIOD_MONTH_SIX = "walletActivity.lastSixMonts";
var ACTIVITY_STATUS_SUCCESSFUL = "walletActivity.successful";
var ACTIVITY_STATUS_UNSUCCESSFUL = "walletActivity.unsuccessful";
var ACTIVITY_STATUS_PENDING = "walletActivity.pending";
var ACTIVITY_STATUS_CANCELLED = "walletActivity.cancelled";
var ACTIVITY_STATUS_CANCELLING = "walletActivity.cancelling";
var COMMUNICATION_NOTIFICATIONS = {
  IFRAME_STATUS: "iframe_status",
  // Tell embed to create the window
  CREATE_WINDOW: "create_window",
  // Tell embed to close the window
  CLOSE_WINDOW: "close_window",
  USER_LOGGED_IN: "user_logged_in",
  USER_LOGGED_OUT: "user_logged_out"
};
var COMMUNICATION_JRPC_METHODS = {
  LOGOUT: "logout",
  WALLET_INSTANCE_ID: "wallet_instance_id",
  USER_INFO: "user_info",
  SET_PROVIDER: "set_provider",
  TOPUP: "topup",
  IFRAME_STATUS: "iframe_status",
  // embed has opened the window as requested
  OPENED_WINDOW: "opened_window",
  // user has closed the window from embed's side
  CLOSED_WINDOW: "closed_window",
  GET_PROVIDER_STATE: "get_provider_state",
  LOGIN_WITH_PRIVATE_KEY: "login_with_private_key"
};
var PROVIDER_JRPC_METHODS = {
  GET_PROVIDER_STATE: "wallet_get_provider_state"
};
var PROVIDER_NOTIFICATIONS = {
  ACCOUNTS_CHANGED: "wallet_accounts_changed",
  CHAIN_CHANGED: "wallet_chain_changed",
  UNLOCK_STATE_CHANGED: "wallet_unlock_state_changed"
};
var BROADCAST_CHANNELS = {
  REDIRECT_CHANNEL: "redirect_channel",
  PROVIDER_CHANGE_CHANNEL: "torus_provider_change_channel",
  TRANSACTION_CHANNEL: "torus_channel",
  MESSAGE_CHANNEL: "torus_message_channel",
  WALLET_LOGOUT_CHANNEL: "wallet_logout_channel",
  WALLET_SELECTED_ADDRESS_CHANNEL: "wallet_selected_address_channel",
  WALLET_NETWORK_CHANGE_CHANNEL: "wallet_network_change_channel",
  WALLET_ACCOUNT_IMPORT_CHANNEL: "wallet_account_import_channel",
  THEME_CHANGE: "theme_change_channel"
};
var BROADCAST_CHANNELS_MSGS = {
  LOGOUT: "logout",
  ACCOUNT_IMPORTED: "account_imported",
  SELECTED_ADDRESS_CHANGE: "selected_address_change",
  NETWORK_CHANGE: "network_change",
  SET_THEME: "set_theme"
};

function createChangeProviderMiddlewareMiddleware(_ref) {
  var changeProvider = _ref.changeProvider;
  return createAsyncMiddleware( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(request, response, next) {
      var method;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              method = request.method;
              if (!(method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER)) {
                _context.next = 3;
                break;
              }
              return _context.abrupt("return", next());
            case 3:
              if (changeProvider) {
                _context.next = 5;
                break;
              }
              throw new Error("CommunicationMiddleware - opts.changeProvider not provided");
            case 5:
              _context.next = 7;
              return changeProvider(request);
            case 7:
              response.result = _context.sent;
            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function (_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }());
}
function createTopupMiddleware(_ref3) {
  var topup = _ref3.topup;
  return createAsyncMiddleware( /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request, response, next) {
      var method;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              method = request.method;
              if (!(method !== COMMUNICATION_JRPC_METHODS.TOPUP)) {
                _context2.next = 3;
                break;
              }
              return _context2.abrupt("return", next());
            case 3:
              if (topup) {
                _context2.next = 5;
                break;
              }
              throw new Error("CommunicationMiddleware - opts.topup not provided");
            case 5:
              _context2.next = 7;
              return topup(request);
            case 7:
              response.result = _context2.sent;
            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return function (_x4, _x5, _x6) {
      return _ref4.apply(this, arguments);
    };
  }());
}
function createGenericJRPCMiddleware(targetMethod, handler) {
  return createAsyncMiddleware( /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(request, response, next) {
      var method, result;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              method = request.method;
              if (!(method !== targetMethod)) {
                _context3.next = 3;
                break;
              }
              return _context3.abrupt("return", next());
            case 3:
              if (handler) {
                _context3.next = 5;
                break;
              }
              throw new Error("CommunicationMiddleware - ".concat(targetMethod, " not provided"));
            case 5:
              _context3.next = 7;
              return handler(request);
            case 7:
              result = _context3.sent;
              if (result) {
                _context3.next = 10;
                break;
              }
              return _context3.abrupt("return", next());
            case 10:
              response.result = result;
              return _context3.abrupt("return", undefined);
            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return function (_x7, _x8, _x9) {
      return _ref5.apply(this, arguments);
    };
  }());
}
function createCommunicationMiddleware(providerHandlers) {
  var _createScaffoldMiddle;
  var getUserInfo = providerHandlers.getUserInfo,
    getWalletInstanceId = providerHandlers.getWalletInstanceId,
    topup = providerHandlers.topup,
    logout = providerHandlers.logout,
    changeProvider = providerHandlers.changeProvider,
    setIFrameStatus = providerHandlers.setIFrameStatus,
    handleWindowRpc = providerHandlers.handleWindowRpc,
    getProviderState = providerHandlers.getProviderState,
    loginWithPrivateKey = providerHandlers.loginWithPrivateKey;
  return mergeMiddleware([createChangeProviderMiddlewareMiddleware({
    changeProvider: changeProvider
  }), createTopupMiddleware({
    topup: topup
  }), createScaffoldMiddleware((_createScaffoldMiddle = {}, _defineProperty(_createScaffoldMiddle, COMMUNICATION_JRPC_METHODS.LOGOUT, logout), _defineProperty(_createScaffoldMiddle, COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID, getWalletInstanceId), _defineProperty(_createScaffoldMiddle, COMMUNICATION_JRPC_METHODS.USER_INFO, getUserInfo), _defineProperty(_createScaffoldMiddle, COMMUNICATION_JRPC_METHODS.IFRAME_STATUS, setIFrameStatus), _defineProperty(_createScaffoldMiddle, COMMUNICATION_JRPC_METHODS.OPENED_WINDOW, handleWindowRpc), _defineProperty(_createScaffoldMiddle, COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW, handleWindowRpc), _defineProperty(_createScaffoldMiddle, COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE, getProviderState), _createScaffoldMiddle)), createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey)]);
}

function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var BaseEmbedController = /*#__PURE__*/function (_BaseController) {
  _inherits(BaseEmbedController, _BaseController);
  var _super = _createSuper$8(BaseEmbedController);
  function BaseEmbedController(_ref) {
    var _this;
    var _ref$config = _ref.config,
      config = _ref$config === void 0 ? {} : _ref$config,
      state = _ref.state;
    _classCallCheck(this, BaseEmbedController);
    _this = _super.call(this, {
      config: config,
      state: state
    });
    _defineProperty(_assertThisInitialized(_this), "_communicationProviderProxy", void 0);
    _this.defaultState = {
      buttonPosition: "bottom-right",
      isIFrameFullScreen: true,
      apiKey: "torus-default",
      oauthModalVisibility: false,
      loginInProgress: false,
      dappMetadata: {
        name: "",
        icon: ""
      }
    };
    _this.initialize();
    return _this;
  }
  /**
   * Called by orchestrator once while initializing the class
   * @param handlers - JRPC handlers for provider
   * @returns - provider - Returns the providerProxy
   */
  _createClass(BaseEmbedController, [{
    key: "initializeProvider",
    value: function initializeProvider(handlers) {
      var engine = new JRPCEngine();
      var communicationMiddleware = createCommunicationMiddleware(handlers);
      engine.push(communicationMiddleware);
      var communicationProvider = providerFromEngine(engine);
      this.setCommunicationProvider(communicationProvider);
    }
  }, {
    key: "setCommunicationProvider",
    value: function setCommunicationProvider(communicationProvider) {
      if (this._communicationProviderProxy) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this._communicationProviderProxy.setTarget(communicationProvider);
      } else {
        this._communicationProviderProxy = createSwappableProxy(communicationProvider);
      }
    }
  }]);
  return BaseEmbedController;
}(BaseController);

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var CommunicationWindowManager = /*#__PURE__*/function (_SafeEventEmitter) {
  _inherits(CommunicationWindowManager, _SafeEventEmitter);
  var _super = _createSuper$7(CommunicationWindowManager);
  function CommunicationWindowManager() {
    var _this;
    _classCallCheck(this, CommunicationWindowManager);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "handleWindowRpc", function (request, response, next, end) {
      var method = request.method,
        params = request.params;
      if (method === COMMUNICATION_JRPC_METHODS.OPENED_WINDOW) {
        var windowId = params.windowId;
        // I've been informed that a window has been opened
        _this.emit("".concat(windowId, ":opened"));
        response.result = true;
        end();
      } else if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {
        var _windowId = params.windowId;
        // I've been informed that a window has been closed
        _this.emit("".concat(_windowId, ":closed"));
        response.result = true;
        end();
      } else {
        next();
      }
    });
    return _this;
  }
  return _createClass(CommunicationWindowManager);
}(SafeEventEmitter);

var LOGIN_PROVIDER = {
  GOOGLE: "google",
  FACEBOOK: "facebook",
  REDDIT: "reddit",
  DISCORD: "discord",
  TWITCH: "twitch",
  APPLE: "apple",
  LINE: "line",
  GITHUB: "github",
  KAKAO: "kakao",
  LINKEDIN: "linkedin",
  TWITTER: "twitter",
  WEIBO: "weibo",
  WECHAT: "wechat",
  EMAIL_PASSWORDLESS: "email_passwordless"
};
var PAYMENT_PROVIDER = {
  MOONPAY: "moonpay",
  WYRE: "wyre",
  RAMPNETWORK: "rampnetwork",
  XANPOOL: "xanpool",
  MERCURYO: "mercuryo",
  TRANSAK: "transak"
};

var getTxStatusText = function getTxStatusText(txStatus) {
  switch (txStatus) {
    case "rejected":
    case "unapproved":
    case "failed":
      return ACTIVITY_STATUS_UNSUCCESSFUL;
    case "confirmed":
      return ACTIVITY_STATUS_SUCCESSFUL;
    case "submitted":
      return ACTIVITY_STATUS_PENDING;
    case "cancelled":
      return ACTIVITY_STATUS_CANCELLED;
    default:
      return "";
  }
};

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * General utility functions
 */
function intToHex(i) {
  var hex = i.toString(16);
  return "0x".concat(hex);
}
/**
 * Returns a random number. Don't use for cryptographic purposes.
 * @returns a random number
 */
var randomId = function randomId() {
  return Math.random().toString(36).slice(2);
};
/**
 * Pads the front of the given hex string with zeroes until it reaches the
 * target length. If the input string is already longer than or equal to the
 * target length, it is returned unmodified.
 *
 * If the input string is "0x"-prefixed or not a hex string, an error will be
 * thrown.
 *
 * @param hexString - The hexadecimal string to pad with zeroes.
 * @param targetLength - The target length of the hexadecimal string.
 * @returns The input string front-padded with zeroes, or the original string
 * if it was already greater than or equal to to the target length.
 */
function padWithZeroes(hexString, targetLength) {
  if (hexString !== "" && !/^[0-9a-f]+$/i.test(hexString)) {
    throw new Error("Expected an unprefixed hex string. Received: ".concat(hexString));
  }
  if (targetLength < 0) {
    throw new Error("Expected a non-negative integer target length. Received: ".concat(targetLength));
  }
  return String.prototype.padStart.call(hexString, targetLength, "0");
}
/**
 * Concatenate an extended ECDSA signature into a hex string.
 *
 * @param v - The 'v' portion of the signature.
 * @param r - The 'r' portion of the signature.
 * @param s - The 's' portion of the signature.
 * @returns The concatenated ECDSA signature.
 */
function concatSig(v, r, s) {
  var rSig = fromSigned(r);
  var sSig = fromSigned(s);
  var vSig = bufferToInt(v);
  var rStr = padWithZeroes(toUnsigned(rSig).toString("hex"), 64);
  var sStr = padWithZeroes(toUnsigned(sSig).toString("hex"), 64);
  var vStr = stripHexPrefix(intToHex(vSig));
  return addHexPrefix(rStr.concat(sStr, vStr));
}
function timeout$1(duration) {
  return new Promise(function (resolve) {
    var timeoutRef = window.setTimeout(function () {
      resolve();
      window.clearTimeout(timeoutRef);
    }, duration);
  });
}
var getHeaders = function getHeaders(jwt) {
  return {
    headers: {
      Authorization: "Bearer ".concat(jwt),
      "Content-Type": "application/json; charset=utf-8"
    }
  };
};
/**
 * Text/number formatting utilities
 */
var formatSmallNumbers = function formatSmallNumbers(number) {
  var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "usd";
  var noTilde = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var finalNumber = BigNumber.isBigNumber(number) ? number.toNumber() : number;
  if (!Number.isFinite(finalNumber)) return "";
  var value = currency.toLowerCase() === "usd" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));
  var tilde = value > 0 ? "~ " : "";
  return "".concat(currency.toLowerCase() === "usd" || noTilde ? "" : tilde).concat(Number(value), " ").concat(currency.toUpperCase());
};
var addressSlicer = function addressSlicer(address) {
  var sliceLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  if (address.length < 11) {
    return address;
  }
  if (typeof address !== "string") return "";
  return "".concat(address.slice(0, sliceLength), "...").concat(address.slice(-sliceLength));
};
var significantDigits = function significantDigits(number) {
  var perc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var length_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var input = !BigNumber.isBigNumber(number) ? new BigNumber(number) : number;
  if (input.isZero()) return input;
  if (perc) {
    input = input.times(new BigNumber(100));
  }
  var depth;
  if (input.gte(new BigNumber(1))) {
    depth = length_;
  } else {
    depth = length_ - 1 + Math.ceil(Math.log10(new BigNumber("1").div(input).toNumber()));
  }
  var shift = new BigNumber(10).pow(new BigNumber(depth));
  var roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();
  return roundedNumber;
};
var formatDate = function formatDate(inputDate) {
  var monthList = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  var date = new Date(inputDate);
  var day = date.getDate();
  var month = monthList[date.getMonth()];
  var year = date.getFullYear();
  return "".concat(day, " ").concat(month, " ").concat(year);
};
var formatTime = function formatTime(time) {
  return new Date(time).toTimeString().slice(0, 8);
};
/**
 * Network utilities
 */
var transactionMatchesNetwork = function transactionMatchesNetwork(transaction, chainId) {
  if (typeof transaction.chainId !== "undefined") {
    return transaction.chainId === chainId;
  }
  return false;
};
/**
 * Signing utils
 */
var hashMessage = function hashMessage(message) {
  var bufferedMessage = Buffer.from(message, "utf8");
  var el = hashPersonalMessage(bufferedMessage);
  return el;
};
var signMessage = function signMessage(privateKey, data) {
  var privKey = Buffer.from(privateKey, "hex");
  var message = stripHexPrefix(data);
  var msgSig = ecsign(Buffer.from(message, "hex"), privKey);
  var rawMsgSig = concatSig(intToBuffer(msgSig.v), msgSig.r, msgSig.s);
  return rawMsgSig;
};
/**
 * popup handler utils
 */
function getPopupFeatures(_ref) {
  var w = _ref.width,
    h = _ref.height;
  // Fixes dual-screen position                             Most browsers      Firefox
  var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
  var dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
  var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  var systemZoom = 1; // No reliable estimate
  var left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
  var top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
  var features = "titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=".concat(h / systemZoom, ",width=").concat(w / systemZoom, ",top=").concat(top, ",left=").concat(left);
  return features;
}
var broadcastChannelOptions = {
  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']
  webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)
};

function getCustomDeviceInfo() {
  var _navigator;
  if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {
    return {
      browser: "Brave"
    };
  }
}
var UserError = /*#__PURE__*/function (_Error) {
  _inherits(UserError, _Error);
  var _super = _createSuper$6(UserError);
  function UserError() {
    _classCallCheck(this, UserError);
    return _super.apply(this, arguments);
  }
  return _createClass(UserError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var handleRedirectParameters = function handleRedirectParameters(hash, queryParameters) {
  var hashParameters = {};
  var hashUrl = new URL("".concat(window.location.origin, "/?").concat(hash.slice(1)));
  hashUrl.searchParams.forEach(function (value, key) {
    hashParameters[key] = value;
  });
  var instanceParameters = {};
  var error = "";
  if (!queryParameters.windowId) {
    if (Object.keys(hashParameters).length > 0 && hashParameters.state) {
      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};
      error = hashParameters.error_description || hashParameters.error || error;
    } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {
      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};
      if (queryParameters.error) error = queryParameters.error;
    }
  }
  return {
    error: error,
    instanceParameters: instanceParameters,
    hashParameters: hashParameters
  };
};
function sleep(ms) {
  return new Promise(function (resolve) {
    setTimeout(resolve, ms);
  });
}

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var BaseKeyringController = /*#__PURE__*/function (_BaseController) {
  _inherits(BaseKeyringController, _BaseController);
  var _super = _createSuper$5(BaseKeyringController);
  function BaseKeyringController(_ref) {
    var _state$wallets;
    var _this;
    var _ref$config = _ref.config,
      config = _ref$config === void 0 ? {} : _ref$config,
      state = _ref.state;
    _classCallCheck(this, BaseKeyringController);
    _this = _super.call(this, {
      config: config,
      state: state
    });
    _this.defaultState = {
      wallets: (_state$wallets = state.wallets) !== null && _state$wallets !== void 0 ? _state$wallets : []
    };
    _this.initialize();
    return _this;
  }
  // for signing auth message
  _createClass(BaseKeyringController, [{
    key: "signAuthMessage",
    value: function signAuthMessage(address, message) {
      var keyring = this.state.wallets.find(function (x) {
        return x.address === address;
      });
      if (!keyring) {
        throw new Error("key does not exist");
      }
      var hashedMessage = hashMessage(message).toString("hex");
      var rawMessageSig = signMessage(keyring.privateKey, hashedMessage);
      return rawMessageSig;
    }
  }]);
  return BaseKeyringController;
}(BaseController);

var RETRIABLE_ERRORS = [
// ignore server overload errors
"Gateway timeout", "ETIMEDOUT",
// ignore server sent html error pages
// or truncated json responses
"failed to parse response body",
// ignore errors where http req failed to establish
"Failed to fetch"];
function checkForHttpErrors(fetchRes) {
  // check for errors
  switch (fetchRes.status) {
    case 405:
      throw ethErrors.rpc.methodNotFound();
    case 418:
      throw ethErrors.rpc.internal({
        message: "Request is being rate limited."
      });
    case 503:
    case 504:
      throw ethErrors.rpc.internal({
        message: "Gateway timeout. The request took too long to process." + "This can happen when querying over too wide a block range."
      });
  }
}
function timeout(duration) {
  return new Promise(function (resolve) {
    setTimeout(resolve, duration);
  });
}
function parseResponse(fetchRes, body) {
  // check for error code
  if (fetchRes.status !== 200) {
    throw ethErrors.rpc.internal({
      message: "Non-200 status code: '".concat(fetchRes.status, "'"),
      data: body
    });
  }
  // check for rpc error
  if (body.error) {
    throw ethErrors.rpc.internal({
      data: body.error
    });
  }
  // return successful result
  return body.result;
}
function createFetchConfigFromReq(_ref) {
  var req = _ref.req,
    rpcTarget = _ref.rpcTarget,
    originHttpHeaderKey = _ref.originHttpHeaderKey;
  var parsedUrl = new URL(rpcTarget);
  // prepare payload
  // copy only canonical json rpc properties
  var payload = {
    id: req.id,
    jsonrpc: req.jsonrpc,
    method: req.method,
    params: req.params
  };
  // extract 'origin' parameter from request
  var originDomain = req.origin;
  // serialize request body
  var serializedPayload = JSON.stringify(payload);
  // configure fetch params
  var fetchParams = {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: serializedPayload
  };
  // optional: add request origin as header
  if (originHttpHeaderKey && originDomain) {
    fetchParams.headers[originHttpHeaderKey] = originDomain;
  }
  return {
    fetchUrl: parsedUrl.href,
    fetchParams: fetchParams
  };
}
function createFetchMiddleware(_ref2) {
  var rpcTarget = _ref2.rpcTarget,
    originHttpHeaderKey = _ref2.originHttpHeaderKey;
  return createAsyncMiddleware( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(req, res, _next) {
      var _createFetchConfigFro, fetchUrl, fetchParams, maxAttempts, retryInterval, attempt, fetchRes, fetchBody, result;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _createFetchConfigFro = createFetchConfigFromReq({
                req: req,
                rpcTarget: rpcTarget,
                originHttpHeaderKey: originHttpHeaderKey
              }), fetchUrl = _createFetchConfigFro.fetchUrl, fetchParams = _createFetchConfigFro.fetchParams; // attempt request multiple times
              maxAttempts = 5;
              retryInterval = 1000;
              attempt = 0;
            case 4:
              if (!(attempt < maxAttempts)) {
                _context.next = 26;
                break;
              }
              _context.prev = 5;
              _context.next = 8;
              return fetch(fetchUrl, fetchParams);
            case 8:
              fetchRes = _context.sent;
              // check for http errrors
              checkForHttpErrors(fetchRes);
              // parse response body
              _context.next = 12;
              return fetchRes.json();
            case 12:
              fetchBody = _context.sent;
              result = parseResponse(fetchRes, fetchBody); // set result and exit retry loop
              res.result = result;
              return _context.abrupt("return");
            case 18:
              _context.prev = 18;
              _context.t0 = _context["catch"](5);
              (function () {
                var errMsg = _context.t0.toString();
                var isRetriable = RETRIABLE_ERRORS.some(function (phrase) {
                  return errMsg.includes(phrase);
                });
                // re-throw error if not retriable
                if (!isRetriable) {
                  throw _context.t0;
                }
              })();
            case 21:
              _context.next = 23;
              return timeout(retryInterval);
            case 23:
              attempt++;
              _context.next = 4;
              break;
            case 26:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[5, 18]]);
    }));
    return function (_x, _x2, _x3) {
      return _ref3.apply(this, arguments);
    };
  }());
}

function createLoggerMiddleware(options) {
  return function loggerMiddleware(request, response, next) {
    next(function (callback) {
      if (response.error) {
        log.warn("Error in RPC response:\n", response);
      }
      if (request.isTorusInternal) return;
      log.info("RPC (".concat(options.origin, "):"), request, "->", response);
      callback();
    });
  };
}

function createOriginMiddleware(options) {
  return function originMiddleware(request, _, next) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    request.origin = options.origin;
    next();
  };
}

var BroadcastChannelHandler = /*#__PURE__*/function () {
  function BroadcastChannelHandler(channelPrefix) {
    _classCallCheck(this, BroadcastChannelHandler);
    _defineProperty(this, "bc", void 0);
    _defineProperty(this, "channel", void 0);
    var queryParameters = new URLSearchParams(window.location.search);
    var instanceId = queryParameters.get("instanceId");
    this.channel = "".concat(channelPrefix, "_").concat(instanceId);
    this.bc = new BroadcastChannel(this.channel, broadcastChannelOptions);
  }
  _createClass(BroadcastChannelHandler, [{
    key: "getMessageFromChannel",
    value: function getMessageFromChannel() {
      var _this = this;
      return new Promise(function (resolve, reject) {
        _this.bc.addEventListener("message", /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ev) {
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _this.bc.close();
                    if (ev.error) {
                      reject(ev.error);
                    } else {
                      resolve(ev.data);
                    }
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }());
        _this.bc.postMessage({
          data: {
            type: POPUP_LOADED
          }
        });
      });
    }
  }]);
  return BroadcastChannelHandler;
}();

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var StreamWindow = /*#__PURE__*/function (_BaseController) {
  _inherits(StreamWindow, _BaseController);
  var _super = _createSuper$4(StreamWindow);
  // if window has been closed by users

  function StreamWindow(_ref) {
    var _this;
    var config = _ref.config,
      _ref$state = _ref.state,
      state = _ref$state === void 0 ? {} : _ref$state;
    _classCallCheck(this, StreamWindow);
    _this = _super.call(this, {
      config: config,
      state: state
    });
    _defineProperty(_assertThisInitialized(_this), "closed", false);
    _this.initialize();
    return _this;
  }
  _createClass(StreamWindow, [{
    key: "open",
    value: function () {
      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _this2 = this;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", new Promise(function (resolve, reject) {
                  var _this2$config = _this2.config,
                    communicationEngine = _this2$config.communicationEngine,
                    communicationWindowManager = _this2$config.communicationWindowManager;
                  var popupSuccess = false;
                  communicationWindowManager.once("".concat(_this2.state.windowId, ":closed"), function () {
                    _this2.closed = true;
                  });
                  // Window is not open yet
                  if (!_this2.state.windowId) {
                    _this2.update({
                      windowId: randomId()
                    });
                    communicationWindowManager.once("".concat(_this2.state.windowId, ":opened"), function () {
                      resolve(_this2);
                    });
                    // Tell the other party to create a window by prompting the user to click on something
                    communicationEngine.emit("notification", {
                      method: COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW,
                      params: {
                        windowId: _this2.state.windowId,
                        url: _this2.state.url.href
                      }
                    });
                  } else {
                    // Send this window with `windowId` the url to open via bc
                    var bc = new BroadcastChannel(_this2.state.windowId, broadcastChannelOptions);
                    bc.addEventListener("message", /*#__PURE__*/function () {
                      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ev) {
                        var error, message;
                        return _regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                _context.prev = 0;
                                log.info(ev, "receiving data on channel: ".concat(bc.name));
                                error = ev.error;
                                if (!error) {
                                  _context.next = 6;
                                  break;
                                }
                                // Popup says some error. so, we say it's not really opened
                                reject(new Error(error));
                                return _context.abrupt("return");
                              case 6:
                                message = ev.data.message;
                                if (!(message === POPUP_LOADED)) {
                                  _context.next = 13;
                                  break;
                                }
                                popupSuccess = true;
                                _context.next = 11;
                                return bc.postMessage({
                                  data: {
                                    url: _this2.state.url.href,
                                    message: "" // No need of a msg
                                  }
                                });
                              case 11:
                                resolve(_this2);
                                bc.close();
                              case 13:
                                _context.next = 20;
                                break;
                              case 15:
                                _context.prev = 15;
                                _context.t0 = _context["catch"](0);
                                reject(_context.t0);
                                bc.close();
                                // Something went wrong. so, we close that window
                                _this2.close();
                              case 20:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee, null, [[0, 15]]);
                      }));
                      return function (_x) {
                        return _ref2.apply(this, arguments);
                      };
                    }());
                    // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something
                    // we need backoff strategy
                    // we need to wait for first attempt to succeed/fail until the second attempt
                    // If we get 429, we need to wait for a while and then try again
                    var postMsg = /*#__PURE__*/function () {
                      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
                        var localResponse;
                        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                _context2.next = 2;
                                return bc.postMessage({
                                  data: {
                                    message: SETUP_COMPLETE
                                  }
                                });
                              case 2:
                                localResponse = _context2.sent;
                                return _context2.abrupt("return", localResponse);
                              case 4:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _callee2);
                      }));
                      return function postMsg() {
                        return _ref3.apply(this, arguments);
                      };
                    }();
                    var currentDelay = bc.type === "server" ? 1000 : 200;
                    var recursiveFn = /*#__PURE__*/function () {
                      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
                        var localResponse, serverResponse;
                        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                if (!(!popupSuccess && !_this2.closed)) {
                                  _context3.next = 9;
                                  break;
                                }
                                _context3.next = 3;
                                return postMsg();
                              case 3:
                                localResponse = _context3.sent;
                                if (bc.type === "server") {
                                  serverResponse = localResponse;
                                  if (serverResponse.status >= 400) {
                                    // We need to wait for a while and then try again
                                    currentDelay = Math.round(currentDelay * 1.5);
                                  }
                                }
                                _context3.next = 7;
                                return sleep(currentDelay);
                              case 7:
                                _context3.next = 9;
                                return recursiveFn();
                              case 9:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _callee3);
                      }));
                      return function recursiveFn() {
                        return _ref4.apply(this, arguments);
                      };
                    }();
                    recursiveFn();
                  }
                }));
              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      function open() {
        return _open.apply(this, arguments);
      }
      return open;
    }()
  }, {
    key: "close",
    value: function close() {
      var communicationEngine = this.config.communicationEngine;
      communicationEngine.emit("notification", {
        method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,
        params: {
          windowId: this.state.windowId
        }
      });
    }
  }]);
  return StreamWindow;
}(BaseController);

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/*
Scenarios:
1. Open a normal popup window and no communication with it - Use PopupHandler
2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)

3. If window is already opened, pass in windowId to the popup handler.
   This will establish communication with the popup window and sends it a new url to redirect to


If you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),
StreamWindow is invoked and it writes in a channel to display a message to the user

Once user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)
*/
/**
 * Handles popup window management.
 * For broadcast channel communication, use url with `instanceId` coded into state parameter.
 * This state parameter will be passed across redirects according to OAuth spec.
 */
var PopupHandler = /*#__PURE__*/function (_BaseController) {
  _inherits(PopupHandler, _BaseController);
  var _super = _createSuper$3(PopupHandler);
  function PopupHandler(_ref) {
    var _this;
    var config = _ref.config,
      state = _ref.state;
    _classCallCheck(this, PopupHandler);
    _this = _super.call(this, {
      config: config,
      state: state
    });
    // this.id = randomId()
    // Add in dapp storage key to all popups as a hash parameter
    _this.defaultConfig = {
      dappStorageKey: "",
      features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),
      target: "_blank",
      communicationEngine: null,
      communicationWindowManager: null
    };
    _this.defaultState = {
      windowTimer: null,
      window: null,
      iClosedWindow: false,
      windowId: "",
      url: state.url
    };
    _this.initialize();
    _this._setupTimer();
    return _this;
  }
  _createClass(PopupHandler, [{
    key: "open",
    value: function () {
      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _this$config, target, features, dappStorageKey, communicationEngine, communicationWindowManager, _this$state, windowId, url, urlHashParams, _localWindow, localWindow;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // if window is already open
                _this$config = this.config, target = _this$config.target, features = _this$config.features, dappStorageKey = _this$config.dappStorageKey, communicationEngine = _this$config.communicationEngine, communicationWindowManager = _this$config.communicationWindowManager;
                _this$state = this.state, windowId = _this$state.windowId, url = _this$state.url;
                if (dappStorageKey) {
                  urlHashParams = new URLSearchParams(url.hash.slice(1));
                  urlHashParams.append("dappStorageKey", dappStorageKey);
                  url.hash = urlHashParams.toString();
                  this.update({
                    url: url
                  });
                }
                // No window has been pre-opened
                if (windowId) {
                  _context.next = 8;
                  break;
                }
                // try to open a window first
                _localWindow = window.open(url.href, target, features);
                if (!_localWindow) {
                  // if it's blocked, open StreamWindow
                  _localWindow = new StreamWindow({
                    config: {
                      communicationEngine: communicationEngine,
                      communicationWindowManager: communicationWindowManager
                    },
                    state: {
                      url: url
                    }
                  });
                  _localWindow.open();
                }
                this.update({
                  window: _localWindow
                });
                return _context.abrupt("return");
              case 8:
                // A window has been pre-opened with a query parameter `windowId`
                localWindow = new StreamWindow({
                  config: {
                    communicationEngine: communicationEngine,
                    communicationWindowManager: communicationWindowManager
                  },
                  state: {
                    url: url,
                    windowId: windowId
                  }
                });
                this.update({
                  window: localWindow
                });
                _context.next = 12;
                return localWindow.open();
              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function open() {
        return _open.apply(this, arguments);
      }
      return open;
    }()
  }, {
    key: "close",
    value: function close() {
      this.update({
        iClosedWindow: true
      });
      var window = this.state.window;
      if (window) window.close();
    }
  }, {
    key: "_setupTimer",
    value: function _setupTimer() {
      var _this2 = this;
      var timer = window.setInterval(function () {
        var _this2$state = _this2.state,
          window = _this2$state.window,
          windowTimer = _this2$state.windowTimer,
          iClosedWindow = _this2$state.iClosedWindow;
        if (window && window.closed) {
          if (windowTimer) clearInterval(windowTimer);
          if (!iClosedWindow) {
            _this2.emit("close");
          }
          _this2.update({
            iClosedWindow: false,
            window: null
          });
        }
        if (window === null && windowTimer) clearInterval(windowTimer);
      }, 500);
      this.update({
        windowTimer: timer
      });
    }
  }]);
  return PopupHandler;
}(BaseController);

var PopupStoreChannel = /*#__PURE__*/function () {
  function PopupStoreChannel(_ref) {
    var instanceId = _ref.instanceId,
      handleLogout = _ref.handleLogout,
      handleAccountImport = _ref.handleAccountImport,
      handleNetworkChange = _ref.handleNetworkChange,
      handleSelectedAddressChange = _ref.handleSelectedAddressChange,
      handleThemeChange = _ref.handleThemeChange;
    _classCallCheck(this, PopupStoreChannel);
    _defineProperty(this, "handleLogout", void 0);
    _defineProperty(this, "handleAccountImport", void 0);
    _defineProperty(this, "handleNetworkChange", void 0);
    _defineProperty(this, "handleThemeChange", void 0);
    _defineProperty(this, "handleSelectedAddressChange", void 0);
    _defineProperty(this, "instanceId", void 0);
    this.instanceId = instanceId;
    this.handleLogout = handleLogout;
    this.handleAccountImport = handleAccountImport;
    this.handleNetworkChange = handleNetworkChange;
    this.handleSelectedAddressChange = handleSelectedAddressChange;
    this.handleThemeChange = handleThemeChange;
  }
  _createClass(PopupStoreChannel, [{
    key: "setupStoreChannels",
    value: function setupStoreChannels() {
      this.logoutChannel();
      this.importAccountChannel();
      this.networkChangeChannel();
      this.selectedAddressChangeChannel();
      this.themeChangedChannel();
    }
  }, {
    key: "logoutChannel",
    value: function logoutChannel() {
      var _this = this;
      var logoutChannel = new BroadcastChannel("".concat(BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL, "_").concat(this.instanceId), broadcastChannelOptions);
      logoutChannel.addEventListener("message", function (ev) {
        var _ev$data;
        log.info("received logout message", ev);
        if (!ev.error && ((_ev$data = ev.data) === null || _ev$data === void 0 ? void 0 : _ev$data.type) === BROADCAST_CHANNELS_MSGS.LOGOUT) {
          log.info("Logging Out");
          _this.handleLogout();
        }
      });
    }
  }, {
    key: "importAccountChannel",
    value: function importAccountChannel() {
      var _this2 = this;
      var walletAccountImportChannel = new BroadcastChannel("".concat(BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL, "_").concat(this.instanceId), broadcastChannelOptions);
      walletAccountImportChannel.addEventListener("message", function (ev) {
        var _ev$data2;
        if (!ev.error && ((_ev$data2 = ev.data) === null || _ev$data2 === void 0 ? void 0 : _ev$data2.type) === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {
          var _ev$data3;
          _this2.handleAccountImport((_ev$data3 = ev.data) === null || _ev$data3 === void 0 ? void 0 : _ev$data3.privKey);
        }
      });
    }
  }, {
    key: "networkChangeChannel",
    value: function networkChangeChannel() {
      var _this3 = this;
      var walletAccountImportChannel = new BroadcastChannel("".concat(BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL, "_").concat(this.instanceId), broadcastChannelOptions);
      walletAccountImportChannel.addEventListener("message", function (ev) {
        var _ev$data4;
        if (!ev.error && ((_ev$data4 = ev.data) === null || _ev$data4 === void 0 ? void 0 : _ev$data4.type) === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {
          var _ev$data5;
          _this3.handleNetworkChange((_ev$data5 = ev.data) === null || _ev$data5 === void 0 ? void 0 : _ev$data5.network);
        }
      });
    }
  }, {
    key: "themeChangedChannel",
    value: function themeChangedChannel() {
      var _this4 = this;
      var walletAccountImportChannel = new BroadcastChannel("".concat(BROADCAST_CHANNELS.THEME_CHANGE, "_").concat(this.instanceId), broadcastChannelOptions);
      walletAccountImportChannel.addEventListener("message", function (ev) {
        var _ev$data6;
        log.info({
          ev: ev
        });
        if (!ev.error && ((_ev$data6 = ev.data) === null || _ev$data6 === void 0 ? void 0 : _ev$data6.type) === BROADCAST_CHANNELS_MSGS.SET_THEME) {
          var _ev$data7;
          _this4.handleThemeChange((_ev$data7 = ev.data) === null || _ev$data7 === void 0 ? void 0 : _ev$data7.theme);
        }
      });
    }
  }, {
    key: "selectedAddressChangeChannel",
    value: function selectedAddressChangeChannel() {
      var _this5 = this;
      var walletAccountImportChannel = new BroadcastChannel("".concat(BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL, "_").concat(this.instanceId), broadcastChannelOptions);
      walletAccountImportChannel.addEventListener("message", function (ev) {
        var _ev$data8;
        if (!ev.error && ((_ev$data8 = ev.data) === null || _ev$data8 === void 0 ? void 0 : _ev$data8.type) === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {
          var _ev$data9;
          _this5.handleSelectedAddressChange((_ev$data9 = ev.data) === null || _ev$data9 === void 0 ? void 0 : _ev$data9.selectedAddress);
        }
      });
    }
  }]);
  return PopupStoreChannel;
}();

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.
 */
var PopupWithBcHandler = /*#__PURE__*/function (_PopupHandler) {
  _inherits(PopupWithBcHandler, _PopupHandler);
  var _super = _createSuper$2(PopupWithBcHandler);
  function PopupWithBcHandler(_ref) {
    var _this;
    var config = _ref.config,
      state = _ref.state,
      instanceId = _ref.instanceId;
    _classCallCheck(this, PopupWithBcHandler);
    _this = _super.call(this, {
      config: config,
      state: state
    });
    _defineProperty(_assertThisInitialized(_this), "bc", void 0);
    _this.bc = new BroadcastChannel(instanceId, broadcastChannelOptions);
    return _this;
  }
  /**
   * Receives the data from popup window and closes the window
   * @param successExtraFn - Extra function to be called after the data is received
   * @returns The data to be received
   */
  _createClass(PopupWithBcHandler, [{
    key: "handle",
    value: function handle(successExtraFn) {
      var _this2 = this;
      return new Promise(function (resolve, reject) {
        var closeListener = function closeListener() {
          _this2.bc.close();
          reject(new UserError("user closed popup"));
          _this2.removeListener("close", closeListener);
        };
        _this2.on("close", closeListener);
        _this2.bc.addEventListener("message", /*#__PURE__*/function () {
          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ev) {
            var error, data;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    log.info(ev, "receiving data on channel: ".concat(_this2.bc.name));
                    _context.prev = 1;
                    error = ev.error, data = ev.data;
                    if (!error) {
                      _context.next = 6;
                      break;
                    }
                    reject(new Error(error));
                    return _context.abrupt("return");
                  case 6:
                    if (!successExtraFn) {
                      _context.next = 9;
                      break;
                    }
                    _context.next = 9;
                    return successExtraFn.call(_this2, data);
                  case 9:
                    resolve(data);
                    _context.next = 15;
                    break;
                  case 12:
                    _context.prev = 12;
                    _context.t0 = _context["catch"](1);
                    reject(_context.t0);
                  case 15:
                    _context.prev = 15;
                    _this2.bc.close();
                    _this2.close();
                    return _context.finish(15);
                  case 19:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[1, 12, 15, 19]]);
          }));
          return function (_x) {
            return _ref2.apply(this, arguments);
          };
        }());
        _this2.open().then(function () {
          log.info("opened window ".concat(_this2.bc.name));
          // Opened window. yay.  let the bc events do their job
          return undefined;
        }).catch(function (err) {
          log.error(err, "something went wrong while opening window");
          reject(err);
        });
      });
    }
    /**
     * Use this if we have to send large payloads which don't fit in query/hash params.
     * Waits for ack that popup window is ready to receive data.
     * Receives the data from popup window and closes the window
     * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data
     * @param successExtraFn - Extra function to be called after the data is received
     * @returns The data to be received
     */
  }, {
    key: "handleWithHandshake",
    value: function handleWithHandshake(payload, successExtraFn) {
      var _this3 = this;
      return new Promise(function (resolve, reject) {
        var closeListener = function closeListener() {
          _this3.bc.close();
          reject(new UserError("user closed popup"));
          _this3.removeListener("close", closeListener);
        };
        _this3.on("close", closeListener);
        _this3.bc.addEventListener("message", /*#__PURE__*/function () {
          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(ev) {
            var error, data, _data$type, type;
            return _regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.prev = 0;
                    log.info(ev, "receiving data on channel: ".concat(_this3.bc.name));
                    error = ev.error, data = ev.data;
                    if (!error) {
                      _context2.next = 6;
                      break;
                    }
                    reject(new Error(error));
                    return _context2.abrupt("return");
                  case 6:
                    // Do handshake
                    _data$type = data.type, type = _data$type === void 0 ? "" : _data$type;
                    if (!(type === POPUP_LOADED)) {
                      _context2.next = 12;
                      break;
                    }
                    _context2.next = 10;
                    return _this3.bc.postMessage({
                      data: payload
                    });
                  case 10:
                    _context2.next = 19;
                    break;
                  case 12:
                    if (!(type === POPUP_RESULT)) {
                      _context2.next = 19;
                      break;
                    }
                    if (!successExtraFn) {
                      _context2.next = 16;
                      break;
                    }
                    _context2.next = 16;
                    return successExtraFn.call(_this3, data);
                  case 16:
                    resolve(data);
                    // Must only close the bc after result is done
                    _this3.bc.close();
                    _this3.close();
                  case 19:
                    _context2.next = 26;
                    break;
                  case 21:
                    _context2.prev = 21;
                    _context2.t0 = _context2["catch"](0);
                    reject(_context2.t0);
                    _this3.bc.close();
                    _this3.close();
                  case 26:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, null, [[0, 21]]);
          }));
          return function (_x2) {
            return _ref3.apply(this, arguments);
          };
        }());
        _this3.open().then(function () {
          log.info("opened window ".concat(_this3.bc.name));
          // Opened window. yay.  let the bc events do their job
          return undefined;
        }).catch(function (err) {
          log.error(err, "something went wrong while opening window");
          reject(err);
        });
      });
    }
  }]);
  return PopupWithBcHandler;
}(PopupHandler);

var RedirectHandler = /*#__PURE__*/function () {
  function RedirectHandler() {
    var _this = this;
    _classCallCheck(this, RedirectHandler);
    _defineProperty(this, "error", void 0);
    _defineProperty(this, "finalQueryParams", {});
    _defineProperty(this, "instanceParameters", void 0);
    _defineProperty(this, "hashParameters", void 0);
    var hash = window.location.hash;
    var queryParameters = new URLSearchParams(window.location.search);
    queryParameters.forEach(function (value, key) {
      _this.finalQueryParams[key] = value;
    });
    var _handleRedirectParame = handleRedirectParameters(hash, this.finalQueryParams),
      error = _handleRedirectParame.error,
      instanceParameters = _handleRedirectParame.instanceParameters,
      hashParameters = _handleRedirectParame.hashParameters;
    this.error = error;
    this.instanceParameters = instanceParameters;
    this.hashParameters = hashParameters;
  }
  _createClass(RedirectHandler, [{
    key: "handle",
    value: function () {
      var _handle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this2 = this;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", new Promise(function (resolve, reject) {
                  var finalQueryParams = _this2.finalQueryParams,
                    instanceParameters = _this2.instanceParameters,
                    hashParameters = _this2.hashParameters,
                    error = _this2.error;
                  var bc;
                  try {
                    if (!finalQueryParams.windowId) {
                      bc = new BroadcastChannel("".concat(BROADCAST_CHANNELS.REDIRECT_CHANNEL, "_").concat(instanceParameters.instanceId), broadcastChannelOptions);
                      bc.addEventListener("message", /*#__PURE__*/function () {
                        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ev) {
                          return _regeneratorRuntime.wrap(function _callee$(_context) {
                            while (1) {
                              switch (_context.prev = _context.next) {
                                case 0:
                                  if (ev.error) {
                                    reject(ev.error);
                                    window.close();
                                  } else {
                                    resolve();
                                    bc.close();
                                    log.info("posted", {
                                      finalQueryParams: finalQueryParams,
                                      hashParameters: hashParameters,
                                      instanceParameters: instanceParameters
                                    });
                                  }
                                case 1:
                                case "end":
                                  return _context.stop();
                              }
                            }
                          }, _callee);
                        }));
                        return function (_x) {
                          return _ref.apply(this, arguments);
                        };
                      }());
                      bc.postMessage({
                        data: {
                          instanceParams: instanceParameters,
                          hashParams: hashParameters,
                          queryParams: finalQueryParams
                        },
                        error: error
                      });
                      setTimeout(function () {
                        resolve();
                        window.location.href = window.location.origin + window.location.search + window.location.hash;
                      }, 5000);
                    } else {
                      bc = new BroadcastChannel("".concat(finalQueryParams.windowId), broadcastChannelOptions);
                      bc.addEventListener("message", /*#__PURE__*/function () {
                        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(ev) {
                          var _ev$data, url, message;
                          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                            while (1) {
                              switch (_context2.prev = _context2.next) {
                                case 0:
                                  _ev$data = ev.data, url = _ev$data.url, message = _ev$data.message;
                                  if (!url) {
                                    _context2.next = 6;
                                    break;
                                  }
                                  resolve();
                                  window.location.href = url;
                                  _context2.next = 9;
                                  break;
                                case 6:
                                  if (!(message === SETUP_COMPLETE)) {
                                    _context2.next = 9;
                                    break;
                                  }
                                  _context2.next = 9;
                                  return bc.postMessage({
                                    data: {
                                      windowId: finalQueryParams.windowId,
                                      message: POPUP_LOADED
                                    }
                                  });
                                case 9:
                                  if (ev.error && ev.error !== "") {
                                    log.error(ev.error);
                                    resolve();
                                    bc.close();
                                  }
                                case 10:
                                case "end":
                                  return _context2.stop();
                              }
                            }
                          }, _callee2);
                        }));
                        return function (_x2) {
                          return _ref2.apply(this, arguments);
                        };
                      }());
                    }
                  } catch (err) {
                    log.info(err, "something went wrong");
                    reject(err);
                    if (bc) bc.close();
                    window.close();
                  }
                }));
              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      function handle() {
        return _handle.apply(this, arguments);
      }
      return handle;
    }()
  }]);
  return RedirectHandler;
}();

var ACTIVITY_ACTION = {
  ACTIVITY_ACTION_ALL: "walletActivity.allTransactions",
  ACTIVITY_ACTION_SEND: "walletActivity.send",
  ACTIVITY_ACTION_RECEIVE: "walletActivity.receive",
  ACTIVITY_ACTION_TOPUP: "walletActivity.topup"
};
var ACCOUNT_CATEGORY = {
  NORMAL: "normal",
  THRESHOLD: "threshold",
  IMPORTED: "imported"
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// By default, poll every 3 minutes
var DEFAULT_INTERVAL = 180 * 1000;
var DEFAULT_PREFERENCES = {
  selectedCurrency: "USD",
  theme: "dark",
  locale: "en-US",
  accountType: ACCOUNT_CATEGORY.NORMAL,
  contacts: [],
  jwtToken: "",
  fetchedPastTx: [],
  pastTransactions: [],
  paymentTx: [],
  defaultPublicAddress: "",
  customTokens: [],
  customNfts: [],
  crashReport: true,
  userInfo: {
    aggregateVerifier: "",
    email: "",
    name: "",
    profileImage: "",
    typeOfLogin: LOGIN_PROVIDER.GOOGLE,
    verifier: "",
    verifierId: ""
  }
};
/**
 * Controller that stores shared settings and exposes convenience methods
 */
var BasePreferencesController = /*#__PURE__*/function (_BaseController) {
  _inherits(BasePreferencesController, _BaseController);
  var _super = _createSuper$1(BasePreferencesController);
  /**
   * Name of this controller used during composition
   */

  /**
   * Creates a PreferencesController instance
   *
   * @param config - Initial options used to configure this controller
   * @param state - Initial state to set on this controller
   */
  function BasePreferencesController(_ref) {
    var _this;
    var config = _ref.config,
      state = _ref.state,
      defaultPreferences = _ref.defaultPreferences,
      signAuthMessage = _ref.signAuthMessage;
    _classCallCheck(this, BasePreferencesController);
    _this = _super.call(this, {
      config: config,
      state: state
    });
    _defineProperty(_assertThisInitialized(_this), "name", "PreferencesController");
    _defineProperty(_assertThisInitialized(_this), "iframeOrigin", void 0);
    _defineProperty(_assertThisInitialized(_this), "signAuthMessage", void 0);
    _defineProperty(_assertThisInitialized(_this), "defaultPreferences", void 0);
    if (!config.api) {
      throw new Error("PreferencesController - no api specified in config.");
    }
    _this.defaultState = {
      identities: {},
      selectedAddress: "",
      lastErrorMessage: "",
      lastSuccessMessage: ""
    };
    _this.defaultConfig = {
      api: config.api,
      pollInterval: DEFAULT_INTERVAL
    };
    _this.initialize();
    _this.defaultPreferences = _objectSpread$1(_objectSpread$1({}, DEFAULT_PREFERENCES), defaultPreferences);
    _this.signAuthMessage = signAuthMessage;
    return _this;
  }
  _createClass(BasePreferencesController, [{
    key: "setIframeOrigin",
    value: function setIframeOrigin(origin) {
      this.iframeOrigin = origin;
    }
  }, {
    key: "getAddressState",
    value: function getAddressState(address) {
      var selectedAddress = address || this.state.selectedAddress;
      return this.state.identities[selectedAddress];
    }
    /**
     * Sets selected address
     *
     * @param selectedAddress - casper account hash
     */
  }, {
    key: "setSelectedAddress",
    value: function setSelectedAddress(selectedAddress) {
      this.update({
        selectedAddress: selectedAddress
      });
    }
  }, {
    key: "getUser",
    value: function () {
      var _getUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address) {
        var user;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return get("".concat(this.config.api, "/user?fetchTx=false"), this.headers(address), {
                  useAPIKey: true
                });
              case 2:
                user = _context.sent;
                return _context.abrupt("return", user.data);
              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function getUser(_x) {
        return _getUser.apply(this, arguments);
      }
      return getUser;
    }()
  }, {
    key: "createUser",
    value: function () {
      var _createUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(params) {
        var selectedCurrency, theme, verifier, verifierId, locale, address, idToken, userPayload;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                selectedCurrency = params.selectedCurrency, theme = params.theme, verifier = params.verifier, verifierId = params.verifierId, locale = params.locale, address = params.address, idToken = params.idToken;
                userPayload = {
                  default_currency: selectedCurrency,
                  theme: theme,
                  verifier: verifier,
                  verifier_id: verifierId,
                  locale: locale,
                  idToken: idToken
                };
                _context2.next = 4;
                return post("".concat(this.config.api, "/user"), userPayload, this.headers(address), {
                  useAPIKey: true
                });
              case 4:
                this.updateState({
                  theme: theme,
                  defaultPublicAddress: address,
                  selectedCurrency: selectedCurrency,
                  locale: locale
                }, address);
              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
      function createUser(_x2) {
        return _createUser.apply(this, arguments);
      }
      return createUser;
    }()
  }, {
    key: "storeUserLogin",
    value: function () {
      var _storeUserLogin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(params) {
        var verifierId, verifier, options, address, idToken, browser, specialBrowser, recordLoginPayload;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                verifierId = params.verifierId, verifier = params.verifier, options = params.options, address = params.address, idToken = params.idToken;
                if (options.rehydrate) {
                  _context3.next = 7;
                  break;
                }
                browser = bowser.getParser(window.navigator.userAgent);
                specialBrowser = getCustomDeviceInfo();
                recordLoginPayload = {
                  os: browser.getOSName(),
                  os_version: browser.getOSVersion() || "unidentified",
                  browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || "unidentified",
                  browser_version: browser.getBrowserVersion() || "unidentified",
                  platform: browser.getPlatform().type || "desktop",
                  hostname: this.iframeOrigin,
                  verifier: verifier,
                  verifier_id: verifierId,
                  idToken: idToken
                };
                _context3.next = 7;
                return post("".concat(this.config.api, "/user/recordLogin"), recordLoginPayload, this.headers(address), {
                  useAPIKey: true
                });
              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
      function storeUserLogin(_x3) {
        return _storeUserLogin.apply(this, arguments);
      }
      return storeUserLogin;
    }()
  }, {
    key: "setCrashReport",
    value: function () {
      var _setCrashReport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(isEnabled) {
        var _this$getAddressState;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport))) {
                  _context4.next = 2;
                  break;
                }
                return _context4.abrupt("return", true);
              case 2:
                _context4.prev = 2;
                _context4.next = 5;
                return patch("".concat(this.config.api, "/user"), {
                  enable_crash_reporter: isEnabled
                }, this.headers(), {
                  useAPIKey: true
                });
              case 5:
                this.updateState({
                  crashReport: isEnabled
                });
                return _context4.abrupt("return", true);
              case 9:
                _context4.prev = 9;
                _context4.t0 = _context4["catch"](2);
                log.error(_context4.t0);
                return _context4.abrupt("return", false);
              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[2, 9]]);
      }));
      function setCrashReport(_x4) {
        return _setCrashReport.apply(this, arguments);
      }
      return setCrashReport;
    }()
  }, {
    key: "setUserTheme",
    value: function () {
      var _setUserTheme = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(theme) {
        var _this$getAddressState2;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme))) {
                  _context5.next = 2;
                  break;
                }
                return _context5.abrupt("return", true);
              case 2:
                _context5.prev = 2;
                _context5.next = 5;
                return patch("".concat(this.config.api, "/user"), {
                  theme: theme
                }, this.headers(), {
                  useAPIKey: true
                });
              case 5:
                this.updateState({
                  theme: theme
                });
                return _context5.abrupt("return", true);
              case 9:
                _context5.prev = 9;
                _context5.t0 = _context5["catch"](2);
                log.error(_context5.t0);
                return _context5.abrupt("return", false);
              case 13:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[2, 9]]);
      }));
      function setUserTheme(_x5) {
        return _setUserTheme.apply(this, arguments);
      }
      return setUserTheme;
    }()
  }, {
    key: "setUserLocale",
    value: function () {
      var _setUserLocale = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(locale) {
        var _this$getAddressState3;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale))) {
                  _context6.next = 2;
                  break;
                }
                return _context6.abrupt("return");
              case 2:
                _context6.prev = 2;
                _context6.next = 5;
                return patch("".concat(this.config.api, "/user"), {
                  locale: locale
                }, this.headers(), {
                  useAPIKey: true
                });
              case 5:
                this.updateState({
                  locale: locale
                });
                return _context6.abrupt("return", true);
              case 9:
                _context6.prev = 9;
                _context6.t0 = _context6["catch"](2);
                log.error("unable to set locale", _context6.t0);
                return _context6.abrupt("return", false);
              case 13:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[2, 9]]);
      }));
      function setUserLocale(_x6) {
        return _setUserLocale.apply(this, arguments);
      }
      return setUserLocale;
    }()
  }, {
    key: "setSelectedCurrency",
    value: function () {
      var _setSelectedCurrency = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(payload) {
        var _this$getAddressState4;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency))) {
                  _context7.next = 2;
                  break;
                }
                return _context7.abrupt("return", true);
              case 2:
                _context7.prev = 2;
                _context7.next = 5;
                return patch("".concat(this.config.api, "/user"), {
                  default_currency: payload.selectedCurrency
                }, this.headers(), {
                  useAPIKey: true
                });
              case 5:
                this.updateState({
                  selectedCurrency: payload.selectedCurrency
                });
                return _context7.abrupt("return", true);
              case 9:
                _context7.prev = 9;
                _context7.t0 = _context7["catch"](2);
                log.error(_context7.t0);
                return _context7.abrupt("return", false);
              case 13:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[2, 9]]);
      }));
      function setSelectedCurrency(_x7) {
        return _setSelectedCurrency.apply(this, arguments);
      }
      return setSelectedCurrency;
    }()
  }, {
    key: "addContact",
    value: function () {
      var _addContact = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(contact) {
        var _this$getAddressState5, response;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.prev = 0;
                _context8.next = 3;
                return post("".concat(this.config.api, "/contact"), contact, this.headers(), {
                  useAPIKey: true
                });
              case 3:
                response = _context8.sent;
                this.updateState({
                  contacts: [].concat(_toConsumableArray(((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || []), [response.data])
                });
                return _context8.abrupt("return", true);
              case 8:
                _context8.prev = 8;
                _context8.t0 = _context8["catch"](0);
                log.error("unable to add contact", _context8.t0);
                return _context8.abrupt("return", false);
              case 12:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[0, 8]]);
      }));
      function addContact(_x8) {
        return _addContact.apply(this, arguments);
      }
      return addContact;
    }()
  }, {
    key: "deleteContact",
    value: function () {
      var _deleteContact = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(contactId) {
        var _this$getAddressState6, response, finalContacts;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.prev = 0;
                _context9.next = 3;
                return remove("".concat(this.config.api, "/contact/").concat(contactId), {}, this.headers(), {
                  useAPIKey: true
                });
              case 3:
                response = _context9.sent;
                finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter(function (contact) {
                  return contact.id !== response.data.id;
                });
                if (finalContacts) this.updateState({
                  contacts: _toConsumableArray(finalContacts)
                });
                return _context9.abrupt("return", true);
              case 9:
                _context9.prev = 9;
                _context9.t0 = _context9["catch"](0);
                log.error("unable to delete contact", _context9.t0);
                return _context9.abrupt("return", false);
              case 13:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[0, 9]]);
      }));
      function deleteContact(_x9) {
        return _deleteContact.apply(this, arguments);
      }
      return deleteContact;
    }()
  }, {
    key: "revokeDiscord",
    value: function () {
      var _revokeDiscord = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(idToken) {
        var resp;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.prev = 0;
                _context10.next = 3;
                return post("".concat(this.config.api, "/revoke/discord"), {
                  token: idToken
                }, this.headers(), {
                  useAPIKey: true
                });
              case 3:
                resp = _context10.sent;
                log.info(resp);
                _context10.next = 10;
                break;
              case 7:
                _context10.prev = 7;
                _context10.t0 = _context10["catch"](0);
                log.error(_context10.t0);
              case 10:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[0, 7]]);
      }));
      function revokeDiscord(_x10) {
        return _revokeDiscord.apply(this, arguments);
      }
      return revokeDiscord;
    }()
  }, {
    key: "patchPastTx",
    value: function () {
      var _patchPastTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(body, address) {
        var response;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.prev = 0;
                _context11.next = 3;
                return patch("".concat(this.config.api, "/transaction"), body, this.headers(address), {
                  useAPIKey: true
                });
              case 3:
                response = _context11.sent;
                log.info("successfully patched", response);
                _context11.next = 10;
                break;
              case 7:
                _context11.prev = 7;
                _context11.t0 = _context11["catch"](0);
                log.error("unable to patch tx", _context11.t0);
              case 10:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[0, 7]]);
      }));
      function patchPastTx(_x11, _x12) {
        return _patchPastTx.apply(this, arguments);
      }
      return patchPastTx;
    }()
  }, {
    key: "postPastTx",
    value: function () {
      var _postPastTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(tx, address) {
        var response;
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.prev = 0;
                _context12.next = 3;
                return post("".concat(this.config.api, "/transaction"), tx, this.headers(address), {
                  useAPIKey: true
                });
              case 3:
                response = _context12.sent;
                log.info("successfully posted tx", response);
                return _context12.abrupt("return", response);
              case 8:
                _context12.prev = 8;
                _context12.t0 = _context12["catch"](0);
                log.error(_context12.t0, "unable to insert transaction");
              case 11:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[0, 8]]);
      }));
      function postPastTx(_x13, _x14) {
        return _postPastTx.apply(this, arguments);
      }
      return postPastTx;
    }()
  }, {
    key: "getWalletOrders",
    value: function () {
      var _getWalletOrders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(address) {
        var response;
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.prev = 0;
                _context13.next = 3;
                return get("".concat(this.config.api, "/transaction"), this.headers(address), {
                  useAPIKey: true
                });
              case 3:
                response = _context13.sent;
                return _context13.abrupt("return", response.success ? response.data ? response.data : [] : []);
              case 7:
                _context13.prev = 7;
                _context13.t0 = _context13["catch"](0);
                log.error("unable to get wallet orders tx", _context13.t0);
                return _context13.abrupt("return", []);
              case 11:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this, [[0, 7]]);
      }));
      function getWalletOrders(_x15) {
        return _getWalletOrders.apply(this, arguments);
      }
      return getWalletOrders;
    }()
  }, {
    key: "getTopUpOrders",
    value: function () {
      var _getTopUpOrders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(address) {
        var response;
        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.prev = 0;
                _context14.next = 3;
                return get("".concat(this.config.commonApiHost, "/transaction"), this.headers(address), {
                  useAPIKey: true
                });
              case 3:
                response = _context14.sent;
                return _context14.abrupt("return", response.data || []);
              case 7:
                _context14.prev = 7;
                _context14.t0 = _context14["catch"](0);
                log.error("unable to fetch past Top up orders", _context14.t0);
              case 10:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[0, 7]]);
      }));
      function getTopUpOrders(_x16) {
        return _getTopUpOrders.apply(this, arguments);
      }
      return getTopUpOrders;
    }()
  }, {
    key: "getBillBoardData",
    value: function () {
      var _getBillBoardData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {
        var response;
        return _regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.prev = 0;
                _context15.next = 3;
                return get("".concat(this.config.api, "/billboard"), this.headers(), {
                  useAPIKey: true
                });
              case 3:
                response = _context15.sent;
                return _context15.abrupt("return", response.success ? response.data : []);
              case 7:
                _context15.prev = 7;
                _context15.t0 = _context15["catch"](0);
                log.error("unable to get billboard data", _context15.t0);
                return _context15.abrupt("return", []);
              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this, [[0, 7]]);
      }));
      function getBillBoardData() {
        return _getBillBoardData.apply(this, arguments);
      }
      return getBillBoardData;
    }()
  }, {
    key: "getMessageForSigning",
    value: function () {
      var _getMessageForSigning = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(publicAddress) {
        var response;
        return _regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return post("".concat(this.config.api, "/auth/message"), {
                  public_address: publicAddress
                }, {}, {
                  useAPIKey: true
                });
              case 2:
                response = _context16.sent;
                return _context16.abrupt("return", response.message);
              case 4:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));
      function getMessageForSigning(_x17) {
        return _getMessageForSigning.apply(this, arguments);
      }
      return getMessageForSigning;
    }()
  }, {
    key: "getTwitterId",
    value: function () {
      var _getTwitterId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(payload) {
        var res;
        return _regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return get("".concat(this.config.api, "/twitter?screen_name=").concat(payload.nick), this.headers(), {
                  useAPIKey: true
                });
              case 2:
                res = _context17.sent;
                return _context17.abrupt("return", "".concat(payload.typeOfLogin.toLowerCase(), "|").concat(res.data.toString()));
              case 4:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));
      function getTwitterId(_x18) {
        return _getTwitterId.apply(this, arguments);
      }
      return getTwitterId;
    }()
  }, {
    key: "sendEmail",
    value: function () {
      var _sendEmail = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(payload) {
        return _regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                return _context18.abrupt("return", post("".concat(this.config.api, "/transaction/sendemail"), payload.emailObject, this.headers(), {
                  useAPIKey: true
                }));
              case 1:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));
      function sendEmail(_x19) {
        return _sendEmail.apply(this, arguments);
      }
      return sendEmail;
    }()
  }, {
    key: "refreshJwt",
    value: function () {
      var _refreshJwt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {
        var address, messageToSign, signedMessage, response;
        return _regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                address = this.state.selectedAddress;
                _context19.next = 3;
                return this.getMessageForSigning(address);
              case 3:
                messageToSign = _context19.sent;
                if (messageToSign.startsWith(this.config.signInPrefix)) {
                  _context19.next = 6;
                  break;
                }
                throw new Error("Cannot sign on invalid message");
              case 6:
                signedMessage = this.signAuthMessage(address, messageToSign);
                _context19.next = 9;
                return post("".concat(this.config.api, "/auth/verify"), {
                  public_address: address,
                  signed_message: signedMessage
                }, {}, {
                  useAPIKey: true
                });
              case 9:
                response = _context19.sent;
                this.updateState({
                  jwtToken: response.token
                }, address);
              case 11:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));
      function refreshJwt() {
        return _refreshJwt.apply(this, arguments);
      }
      return refreshJwt;
    }()
  }, {
    key: "getDappList",
    value: function () {
      var _getDappList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {
        var response;
        return _regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.prev = 0;
                _context20.next = 3;
                return get("".concat(this.config.api, "/dapps"), this.headers(), {
                  useAPIKey: true
                });
              case 3:
                response = _context20.sent;
                return _context20.abrupt("return", response.success ? response.data : []);
              case 7:
                _context20.prev = 7;
                _context20.t0 = _context20["catch"](0);
                log.error("unable to get billboard data", _context20.t0);
                return _context20.abrupt("return", []);
              case 11:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this, [[0, 7]]);
      }));
      function getDappList() {
        return _getDappList.apply(this, arguments);
      }
      return getDappList;
    }()
  }, {
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(address, userInfo, jwtToken) {
        var response, messageToSign, signedMessage;
        return _regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                response = {
                  token: jwtToken
                };
                if (!this.getAddressState(address)) {
                  _context21.next = 3;
                  break;
                }
                return _context21.abrupt("return");
              case 3:
                if (jwtToken) {
                  _context21.next = 13;
                  break;
                }
                _context21.next = 6;
                return this.getMessageForSigning(address);
              case 6:
                messageToSign = _context21.sent;
                if (messageToSign.startsWith(this.config.signInPrefix)) {
                  _context21.next = 9;
                  break;
                }
                throw new Error("Cannot sign on invalid message");
              case 9:
                signedMessage = this.signAuthMessage(address, messageToSign);
                _context21.next = 12;
                return post("".concat(this.config.api, "/auth/verify"), {
                  public_address: address,
                  signed_message: signedMessage
                }, {}, {
                  useAPIKey: true
                });
              case 12:
                response = _context21.sent;
              case 13:
                this.updateState({
                  jwtToken: response.token,
                  userInfo: userInfo
                }, address);
              case 14:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));
      function init(_x20, _x21, _x22) {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "updateState",
    value: function updateState(preferences, address) {
      var selectedAddress = address || this.state.selectedAddress;
      var currentState = this.getAddressState(selectedAddress) || cloneDeep(this.defaultPreferences);
      var mergedState = _objectSpread$1(_objectSpread$1({}, currentState), preferences);
      this.update({
        identities: _objectSpread$1(_objectSpread$1({}, this.state.identities), {}, _defineProperty({}, selectedAddress, mergedState))
      });
      return mergedState;
    }
  }, {
    key: "headers",
    value: function headers(address) {
      var _this$getAddressState7;
      var selectedAddress = address || this.state.selectedAddress;
      return getHeaders(((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || "");
    }
  }]);
  return BasePreferencesController;
}(BaseController);

/**
 * The status of the transaction. Each status represents the state of the transaction internally
 * in the wallet. Some of these correspond with the state of the transaction on the network, but
 * some are wallet-specific.
 */
var TransactionStatus;
(function (TransactionStatus) {
  TransactionStatus["approved"] = "approved";
  TransactionStatus["cancelled"] = "cancelled";
  TransactionStatus["confirmed"] = "confirmed";
  TransactionStatus["failed"] = "failed";
  TransactionStatus["finalized"] = "finalized";
  TransactionStatus["processed"] = "processed";
  TransactionStatus["rejected"] = "rejected";
  TransactionStatus["signed"] = "signed";
  TransactionStatus["submitted"] = "submitted";
  TransactionStatus["unapproved"] = "unapproved";
  TransactionStatus["dropped"] = "dropped";
  TransactionStatus["expired"] = "expired";
})(TransactionStatus || (TransactionStatus = {}));
var TRANSACTION_TYPES = {
  CONTRACT_INTERACTION: "contractInteraction",
  DEPLOY_CONTRACT: "contractDeployment",
  WASM_BASED_DEPLOY: "wasmBasedDeploy",
  STANDARD_TRANSACTION: "transaction",
  STANDARD_PAYMENT_TRANSACTION: "payment_transaction" // specific to chains like solana and casper
};

var TX_EVENTS = {
  TX_WARNING: "tx:warning",
  TX_ERROR: "tx:error",
  TX_FAILED: "tx:failed",
  TX_CONFIRMED: "tx:confirmed",
  TX_DROPPED: "tx:dropped",
  TX_EXPIRED: "tx:expired",
  TX_STATUS_UPDATE: "tx:status_update",
  TX_UNAPPROVED: "tx:unapproved"
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var BaseTransactionStateManager = /*#__PURE__*/function (_BaseController) {
  _inherits(BaseTransactionStateManager, _BaseController);
  var _super = _createSuper(BaseTransactionStateManager);
  function BaseTransactionStateManager(_ref) {
    var _this;
    var config = _ref.config,
      state = _ref.state,
      getCurrentChainId = _ref.getCurrentChainId;
    _classCallCheck(this, BaseTransactionStateManager);
    _this = _super.call(this, {
      config: config,
      state: state
    });
    _defineProperty(_assertThisInitialized(_this), "getCurrentChainId", void 0);
    _this.defaultConfig = {
      txHistoryLimit: 40
    };
    _this.defaultState = {
      transactions: {},
      unapprovedTxs: {},
      currentNetworkTxsList: []
    };
    _this.initialize();
    _this.getCurrentChainId = getCurrentChainId;
    return _this;
  }
  _createClass(BaseTransactionStateManager, [{
    key: "getUnapprovedTxList",
    value: function getUnapprovedTxList() {
      var chainId = this.getCurrentChainId();
      return pickBy(this.state.transactions, function (transaction) {
        return transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId);
      });
    }
  }, {
    key: "getTransaction",
    value: function getTransaction(txId) {
      var transactions = this.state.transactions;
      return transactions[txId];
    }
  }, {
    key: "updateTransaction",
    value: function updateTransaction(txMeta) {
      // commit txMeta to state
      var txId = txMeta.id;
      txMeta.updated_at = new Date().toISOString();
      this.update({
        transactions: _objectSpread(_objectSpread({}, this.state.transactions), {}, _defineProperty({}, txId, txMeta))
      });
    }
  }, {
    key: "setTxStatusRejected",
    value: function setTxStatusRejected(txId) {
      this._setTransactionStatus(txId, TransactionStatus.rejected);
      this._deleteTransaction(txId);
    }
    /**
     * The implementing controller can override this functionality and add custom logic + call super.()
     */
  }, {
    key: "setTxStatusUnapproved",
    value: function setTxStatusUnapproved(txId) {
      this._setTransactionStatus(txId, TransactionStatus.unapproved);
    }
  }, {
    key: "setTxStatusApproved",
    value: function setTxStatusApproved(txId) {
      this._setTransactionStatus(txId, TransactionStatus.approved);
    }
  }, {
    key: "setTxStatusSigned",
    value: function setTxStatusSigned(txId) {
      this._setTransactionStatus(txId, TransactionStatus.signed);
    }
  }, {
    key: "setTxStatusSubmitted",
    value: function setTxStatusSubmitted(txId) {
      this._setTransactionStatus(txId, TransactionStatus.submitted);
    }
  }, {
    key: "setTxStatusDropped",
    value: function setTxStatusDropped(txId) {
      this._setTransactionStatus(txId, TransactionStatus.dropped);
    }
  }, {
    key: "setTxStatusExpired",
    value: function setTxStatusExpired(txId) {
      this._setTransactionStatus(txId, TransactionStatus.expired);
    }
  }, {
    key: "setTxStatusConfirmed",
    value: function setTxStatusConfirmed(txId) {
      this._setTransactionStatus(txId, TransactionStatus.confirmed);
    }
  }, {
    key: "setTxStatusFailed",
    value: function setTxStatusFailed(txId, error_) {
      var error = !error_ ? new Error("Internal torus failure") : error_;
      var txMeta = this.getTransaction(txId);
      txMeta.error = error;
      this.updateTransaction(txMeta);
      this._setTransactionStatus(txId, TransactionStatus.failed);
    }
    /**
     * Method to determine if the transaction is in a final state
     * @param status - Transaction status
     * @returns boolean if the transaction is in a final state
     */
  }, {
    key: "isFinalState",
    value: function isFinalState(status) {
      return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;
    }
    /**
     * Filters out the unapproved transactions from state
     */
  }, {
    key: "clearUnapprovedTxs",
    value: function clearUnapprovedTxs() {
      this.update({
        transactions: omitBy(this.state.transactions, function (transaction) {
          return transaction.status === TransactionStatus.unapproved;
        })
      });
    }
    /**
     * will append new transactions to old txns.
     */
  }, {
    key: "_addTransactionsToState",
    value: function _addTransactionsToState(transactions) {
      this.update({
        transactions: transactions.reduce(function (result, newTx) {
          result[newTx.id] = newTx;
          return result;
        }, this.state.transactions)
      });
    }
    /**
     * will set new txns, override existing if any in state.
     */
  }, {
    key: "_setTransactionsToState",
    value: function _setTransactionsToState(transactions) {
      this.update({
        transactions: transactions.reduce(function (result, newTx) {
          result[newTx.id] = newTx;
          return result;
        }, {})
      });
    }
  }, {
    key: "_deleteTransaction",
    value: function _deleteTransaction(targetTransactionId) {
      var transactions = this.state.transactions;
      delete transactions[targetTransactionId];
      this.update({
        transactions: transactions
      });
    }
  }, {
    key: "_deleteTransactions",
    value: function _deleteTransactions(targetTransactionIds) {
      var transactions = this.state.transactions;
      targetTransactionIds.forEach(function (transactionId) {
        delete transactions[transactionId];
      });
      this.update({
        transactions: transactions
      });
    }
  }, {
    key: "_setTransactionStatus",
    value: function _setTransactionStatus(txId, status) {
      var txMeta = this.getTransaction(txId);
      if (!txMeta) {
        return;
      }
      txMeta.status = status;
      // only updating status so no validation required on txn.
      this.updateTransaction(txMeta);
      this.emit(TX_EVENTS.TX_STATUS_UPDATE, {
        txId: txId,
        status: status
      });
      if (this.isFinalState(status)) {
        this.emit("".concat(txMeta.id, ":finished"), txMeta);
      } else {
        this.emit("".concat(txMeta.id, ":").concat(status), txId);
      }
    }
  }]);
  return BaseTransactionStateManager;
}(BaseController);

export { ACCOUNT_CATEGORY, ACTIVITY_ACTION, ACTIVITY_ACTION_ALL, ACTIVITY_ACTION_BURN, ACTIVITY_ACTION_RECEIVE, ACTIVITY_ACTION_SEND, ACTIVITY_ACTION_TOPUP, ACTIVITY_PERIOD_ALL, ACTIVITY_PERIOD_MONTH_ONE, ACTIVITY_PERIOD_MONTH_SIX, ACTIVITY_PERIOD_WEEK_ONE, ACTIVITY_STATUS_CANCELLED, ACTIVITY_STATUS_CANCELLING, ACTIVITY_STATUS_PENDING, ACTIVITY_STATUS_SUCCESSFUL, ACTIVITY_STATUS_UNSUCCESSFUL, BROADCAST_CHANNELS, BROADCAST_CHANNELS_MSGS, BaseBlockTracker, BaseController, BaseCurrencyController, BaseEmbedController, BaseKeyringController, BasePreferencesController, BaseTransactionStateManager, BroadcastChannelHandler, COMMUNICATION_JRPC_METHODS, COMMUNICATION_NOTIFICATIONS, CommunicationWindowManager, DEFAULT_PREFERENCES, FEATURES_CONFIRM_WINDOW, FEATURES_DEFAULT_POPUP_WINDOW, FEATURES_DEFAULT_WALLET_WINDOW, FEATURES_PROVIDER_CHANGE_WINDOW, LOGIN_PROVIDER, PAYMENT_PROVIDER, POPUP_LOADED, POPUP_RESULT, PROVIDER_JRPC_METHODS, PROVIDER_NOTIFICATIONS, PopupHandler, PopupStoreChannel, PopupWithBcHandler, RedirectHandler, SETUP_COMPLETE, StreamWindow, TRANSACTION_TYPES, TX_EVENTS, TransactionStatus, UserError, addressSlicer, broadcastChannelOptions, concatSig, createChangeProviderMiddlewareMiddleware, createCommunicationMiddleware, createEventEmitterProxy, createFetchConfigFromReq, createFetchMiddleware, createGenericJRPCMiddleware, createLoggerMiddleware, createOriginMiddleware, createRandomId, createSwappableProxy, createTopupMiddleware, formatDate, formatSmallNumbers, formatTime, getCustomDeviceInfo, getHeaders, getPopupFeatures, getTxStatusText, handleRedirectParameters, hashMessage, intToHex, padWithZeroes, providerAsMiddleware, providerFromEngine, providerFromMiddleware, randomId, signMessage, significantDigits, sleep, timeout$1 as timeout, transactionMatchesNetwork };
//# sourceMappingURL=baseControllers.esm.js.map
